import json
import os
from openai import AssistantEventHandler
from typing_extensions import override

from functions import flight_schedule, get_itinerary, getLiveBookings, visa_check


class EventHandler(AssistantEventHandler):
    def __init__(self, sid, client, socketio_instance):
        super().__init__()
        self.sid = sid
        self.client = client
        self.socketio = socketio_instance

    @override
    def on_text_created(self, text) -> None:
        # Log when text is created by the assistant
        print(f"\nassistant > ", end="", flush=True)

    @override
    def on_text_delta(self, delta, snapshot):
        # Log and emit the text delta as it is generated by the assistant
        print(delta.value, end="", flush=True)
        self.socketio.emit("chat message chunk", {"data": delta.value}, room=self.sid)

    def on_tool_call_created(self, tool_call):
        # Log when a tool call is created
        print(f"\nassistant > {tool_call.type}\n", flush=True)

    def on_tool_call_delta(self, delta, snapshot):
        # Handle tool call deltas for code interpreter outputs
        if delta.type == "code_interpreter":
            if delta.code_interpreter.input:
                self.socketio.emit(
                    "chat message chunk",
                    {"data": delta.code_interpreter.input},
                    room=self.sid,
                )
            if delta.code_interpreter.outputs:
                output_logs = "\n".join(
                    [
                        output.logs
                        for output in delta.code_interpreter.outputs
                        if output.type == "logs"
                    ]
                )
                self.socketio.emit(
                    "chat message chunk", {"data": output_logs}, room=self.sid
                )

    @override
    def on_event(self, event):
        # Handle events that require action
        if event.event == "thread.run.requires_action":
            run_id = event.data.id
            self.handle_requires_action(event.data, run_id)

    def handle_requires_action(self, data, run_id):
        # Handle required actions by processing tool calls
        tool_outputs = []
        for tool in data.required_action.submit_tool_outputs.tool_calls:
            if tool.function.name == "get_itinerary":
                arguments = json.loads(tool.function.arguments)
                print(f"{tool.function.name} arguments: {arguments}")
                pnr = arguments["PNR"]
                itinerary = get_itinerary(pnr)
                tool_outputs.append({"tool_call_id": tool.id, "output": itinerary})
            elif tool.function.name == "flight_schedule":
                arguments = json.loads(tool.function.arguments)
                print(f"{tool.function.name} arguments: {arguments}")
                departure_airport = arguments["departure_airport"]
                arrival_airport = arguments["arrival_airport"]
                year = arguments["year"]
                month = arguments["month"]
                day = arguments["day"]
                solution = flight_schedule(
                    departure_airport, arrival_airport, year, month, day
                )
                print(solution)
                tool_outputs.append(
                    {"tool_call_id": tool.id, "output": json.dumps(solution)}
                )
            elif tool.function.name == "visa_check":
                arguments = json.loads(tool.function.arguments)
                print(f"{tool.function.name} arguments: {arguments}")
                passportCountry = arguments.get("passportCountry")
                departureDate = arguments.get("departureDate")
                arrivalDate = arguments.get("arrivalDate")
                departureAirport = arguments.get("departureAirport")
                arrivalAirport = arguments.get("arrivalAirport")
                transitCities = arguments.get("transitCities", [])
                travelPurpose = arguments.get("travelPurpose")
                result = visa_check(
                    passportCountry,
                    departureDate,
                    arrivalDate,
                    departureAirport,
                    arrivalAirport,
                    transitCities,
                    travelPurpose,
                )
                print(result)
                tool_outputs.append(
                    {"tool_call_id": tool.id, "output": json.dumps(result)}
                )
            elif tool.function.name == "getLiveBookings":
                arguments = json.loads(tool.function.arguments)
                print(f"{tool.function.name} arguments: {arguments}")
                role = arguments["role"]
                email = arguments["email"]
                debtorId = arguments["debtorId"]
                bookings = getLiveBookings(role, email, debtorId)
                print(bookings)
                tool_outputs.append(
                    {"tool_call_id": tool.id, "output": json.dumps(bookings)}
                )

        # Submit the tool outputs
        self.submit_tool_outputs(tool_outputs, run_id)

    def submit_tool_outputs(self, tool_outputs, run_id):
        # Stream the tool outputs back to the assistant
        with self.client.beta.threads.runs.submit_tool_outputs_stream(
            thread_id=self.current_run.thread_id,
            run_id=self.current_run.id,
            tool_outputs=tool_outputs,
        ) as stream:
            for text in stream.text_deltas:
                print(text, end="", flush=True)
                self.socketio.emit("chat message chunk", {"data": text}, room=self.sid)
            print()


def add_message_to_thread(thread_id, message, sid, client, socketio):
    # Add a message to the assistant thread
    print(f"\nclient >", message)
    message = client.beta.threads.messages.create(
        thread_id=thread_id, role="user", content=message
    )
    # Stream the assistant's response to the message
    with client.beta.threads.runs.stream(
        thread_id=thread_id,
        assistant_id=os.getenv("ASSISTANT_ID"),
        event_handler=EventHandler(sid, client, socketio),
    ) as stream:
        stream.until_done()
